# Instructions for adding/creating new reactions
- To add a new reaction, 3 header files(and their corresponding folders) need to be added to `src/reactions_lib`.
## Header file for ReactionData
- A header file defining the data and reaction rate calculation for a given reaction needs to be created.
- If necessary, a namespace needs to be created inside this file, storing integer vectors that define the required simple properties and the required species-dependent properties, using variable names defined in an enumerator inside the `standard_properties_enum` struct in `src/reactions_lib/particle_properties_map.hpp`. This struct can be extended if necessary with instructions provided in the documentation for the `standard_properties_enum` struct.
- There would be 2 structs inside this file, one struct is the "on-host" struct that would contain data and functions that are to be stored and used only on the host. The other struct would be the "on-device" for data and functions to be stored and used only on the SYCL device.
- Both structs need to inherit from abstract base structs. The "on-host" struct from `ReactionDataBase` and the "on-device" struct from `ReactionDataBaseOnDevice` both are defined in `src/reactions_lib/reaction_data.hpp`
- The "on-host" struct contains an instance of the "on-device" struct as a member variable and needs a corresponding getter labeled as `get_on_device_obj(...)`.
- Any parameters (or template parameters) that are needed by the "on-device" struct should be passed to the "on-host" struct and then subsequently used in the initialization of the "on-device" object in the constructor of the "on-host" struct.
- Any required properties should also be initialized in the constructor of "on-host" object. The indices of the properties (such that they can be accessed from the Sym vectors passed to `calc_rate`) should be set using the results from the appropriate `..._ prop_index(...)` methods inside the body of the "on-host" struct constructor. The indices should be integers that are public in the "on-device" struct so should be set directly.
## Header file for ReactionKernels
- A header file defining the data and kernels for a given reaction needs to be created.
- If necessary, a namespace needs to be created inside this file, storing integer vectors that define the required simple properties and the required species-dependent properties (using variable names defined in an enumerator in `src/reactions_lib/particle_properties_map.hpp`).
- Any simple or species-dependent properties needed for the descendant products of the reaction kernel also require a corresponding integer vector.
- There would be 2 structs inside this file, one struct is the "on-host" struct that would contain data and functions that are to be stored and used only on the host. The other struct would be the "on-device" for data and functions to be stored and used only on the SYCL device.
- Both structs need to inherit from their own abstract base structs. The "on-host" struct from `ReactionKernelsBase` and the "on-device" struct from `ReactionKernelsBaseOnDevice` both are defined in `src/reactions_lib/reaction_kernels.hpp`
- The "on-host" struct contains an instance of the "on-device" struct as a member variable and needs a corresponding getter labeled as `get_on_device_obj(...)`.
- Any parameters (or template parameters) that are needed by the "on-device" struct should be passed to the "on-host" struct and then subsequently used in the initialization of the "on-device" object in the constructor of the "on-host" struct.
- Firstly within the "on-device" constructor, if there are any descendants produced by the reaction then calls to `this->set_required_descendant_int_props(...)` or `set_required_descendant_real_props(...)` or both need to be made before anything else in the constructor.
- Any required properties should also be initialized in the constructor of "on-host" object. The indices of the properties (such that they can be accessed from the Sym vectors passed to the kernel functions) should be set using the results from the appropriate `..._ prop_index(...)` methods inside the body of the "on-host" struct constructor. The indices should be integers that are public in the "on-device" struct so should be set directly.
- This indices setting needs to be repeated for descendant properties if necessary.
- For descendant-producing reactions one final step is needed - creating and setting a `descendant_matrix_spec`. This is done by creating an empty `ParticleSpec` and pushing `ParticleProp` objects onto it. The `ParticleProp` objects must be constructed manually and crucially must be pushed onto the `ParticleSpec` object's internal `properties_int` and `properties_real` in the same order that they are within the namespace integer vectors. Finally the populated `ParticleSpec` is passed to `product_matrix_spec(...)` and the result is set using `this->set_descendant_matrix_spec(...)`. (An example of a reaction kernel with descendant products can be found in `src/reactions_lib/reaction_kernels/base_cx_kernels.hpp`. Note how the descendant products are used within the individual kernels in the "on-device" struct.)
## Header file for Reaction
- This file should contain a Reaction object that (for now) inherits from `LinearReactionBase`. In this object's constructor there is an option to either pass all parameters (and template parameters) that `LinearReactionBase` needs but these can also be hard-coded at this level. For example, ionisation reactions hard-code the template parameter for `num_products_per_parent` to `0` which means that this template parameter doesn't need to be passed when an instance of the derived struct is initialized.
## Optional - DataCalculator
- If any pre-requisite data is needed for the `run_rate_loop` calculation that will be used in `LinearReactionBase`, then this can be stored in a `DataCalculator` object and passed to `LinearReactionBase`. This requires passing another template parameter to `LinearReactionBase` in the form of `DataCalculator<RateData...>` where `RateData...` is any number of derived reaction data types. Finally a `DataCalculator<RateData...>` initialized object needs to be passed as an argument (after `ParticleSpec`) to the `LinearReactionBase` initializer.
# Example for a AMJUEL 1D ionisation reaction
- 3 files are created: \
 -- `src/reactions_lib/reaction_data/AMJUEL_1D_data.hpp`\
 -- `src/reactions_lib/reactions_kernels/base_ionisation_kernels.hpp` (since this can be used by a fixed rate ionisation reaction as well)\
 -- `src/reactions_lib/derived_reactions/electron_impact_ionisation.hpp`
- The reaction data file contains a namespace `AMJUEL_1D_DATA` that contains the required simple properties (`fluid_density`, `fluid_temperature` and `weight` in this case). Also included are 2 structs: `AMJUEL1DData` and `AMJUEL1DDataOnDevice` (note `num_coeffs` is a template parameter needed by the "on-device" struct and is passed to "on-host" which then uses it in it's initialization of an instance of the "on-device" struct).
- The reaction kernel file follows a similar pattern with a namespace `BASE_IONISATION_KERNEL` and 2 structs: `IoniseReactionKernels` and `IoniseReactionKernelsOnDevice`.
- Finally the main reaction file contains 1 struct: `ElectronImpactIonisation` which inherits from `LinearReactionBase` and hard-codes some parameters for the base struct (such as `num_products_per_parent` being set to 0). A `DataCalculator<EnergyRateData>` template parameter is passed to `LinearReactionBase` and subsequently `DataCalculator<EnergyRateData>(particle_spec, energy_rate_data)` is passed as an argument to the `LinearReactionBase` initializer.
- The `ReactionController.ionisation_reaction_amjuel` test shows how one would go about creating an instance of the reaction.